"""
File: aq.py
Authors: Artsiom Rayeuski, Jan Wisniewski
Date: 21/01/2024
Description: This script implements the AQ algorithm for rule induction.
The AQ algorithm takes a set of instances with corresponding classes, and
it generates rules that accurately classify instances based on their attributes.

Functions:
- aq(data_r, classes_c, data_full_unique):
  Generates rule using the AQ algorithm.
- best_complex(G, same_class):
  Selects the best complex from a list based on instances with the same class.
- contains_complex_or_more_common_complex(G, test_complex):
  Checks if a list of complexes contains the given complex or a more common one.
- split_data(data_r, classes_c, classifier):
  Splits the data into instances with the specified class and instances with other classes.
"""

import copy
import numpy as np
from Rule import Rule


def aq(data_r, classes_c, data_full_unique):
    """
    Generates rules using the AQ algorithm.

    Parameters:
    - data_r (list): List of instances.
    - classes_c (list): List of corresponding classes.
    - data_full_unique (list): Unique values for each attribute in the dataset.

    Returns:
    - Rule: A rule generated by the AQ algorithm.
    """

    G = [data_full_unique]
    x_s = data_r[0]
    d_class = classes_c[0]
    same_class, different_class = split_data(data_r, classes_c, d_class)

    # Flag to check if only one class remains
    one_class_remains = False

    # List to store the modified complexes
    new_G = []

    if len(different_class) == 0:
        one_class_remains = True
    while len(different_class) != 0:
        new_G = []
        x_n = different_class[0]
        different_class.remove(x_n)
        for i in range(len(x_n)):
            if x_s[i] != x_n[i]:
                for i_complex in G:
                    temp_complex = copy.deepcopy(i_complex)
                    if x_n[i] in temp_complex[i]:
                        temp_complex[i].remove(x_n[i])
                        if not contains_complex_or_more_common_complex(new_G, temp_complex):
                            new_G.append(temp_complex)

        # Find the best complex from new_G based on instances with the same class
        new_g = best_complex(new_G, same_class)

        # Create a new list of instances that satisfy the new_g conditions
        new_list = []
        for x in different_class:
            remove = False
            for i in range(len(x)):
                if not x[i] in new_g[i]:
                    remove = True
                    break
            if not remove:
                new_list.append(x)
        # Update different_class and G
        different_class = new_list
        G = [new_g]

    # Choose the final new_g based on whether one_class_remains is True
    if one_class_remains:
        new_g = G[0]
    else:
        new_g = best_complex(new_G, same_class)

    return Rule(new_g, d_class)


def best_complex(G, same_class):
    """
    Selects the best complex from a list based on instances with the same class.

    Parameters:
    - G (list): List of complexes.
    - same_class (list): Instances with the same class.

    Returns:
    - list: The best complex.
    """
    if G is None or len(G) == 0:
        return None
    else:

        # Initialize a list to store the count of instances covered by each complex
        count = []

        for idx, i_complex in enumerate(G):
            # Initialize count for the current complex
            count.append(0)

            # Flag to check if the current instance is within the complex
            in_complex = True

            for data_point in same_class:
                for i in range(len(data_point)):
                    if not data_point[i] in i_complex[i]:
                        # If an attribute value is not in the current complex, set in_complex to False
                        in_complex = False
                        break

                # If the instance is within the complex, increment the count
                if in_complex:
                    count[idx] += 1

        # Return the complex with the maximum count (covering the most instances)
        return G[count.index(max(count))]


def contains_complex_or_more_common_complex(G, test_complex):
    """
    Checks if a list of complexes contains the given complex or a more common one.

    Parameters:
    - G (list): List of complexes.
    - test_complex (list): The complex to check.

    Returns:
    - bool: True if G contains the complex or a more common one, False otherwise.
    """
    contains = True
    if len(G) == 0:
        return False
    for i_complex in G:
        contains = True
        for i in range(len(i_complex)):
            # Check if the attribute values of the test_complex are a subset of the current complex
            if not set(test_complex[i]).issubset(i_complex[i]):
                contains = False
                break
        if contains:
            return True
    return False


def split_data(data_r, classes_c, classifier):
    """
    Splits the data into instances with the specified class and instances with other classes.

    Parameters:
    - data_r (list): List of instances.
    - classes_c (list): List of corresponding classes.
    - classifier: The class to separate.

    Returns:
    - tuple: Instances with the specified class, instances with other classes.
    """

    # Convert input lists to NumPy arrays for efficient array operations
    data = np.array(data_r)
    classes = np.array(classes_c)

    # Create a boolean array indicating instances with the specified class
    classes_r_1 = (classes == classifier)

    # Create a boolean array indicating instances with other classes
    classes_r_0 = ~classes_r_1

    # Extract instances with the specified class using boolean indexing
    same_class = data[classes_r_1]

    # Extract instances with other classes using boolean indexing
    different_class = data[classes_r_0]

    # Convert the result back to lists before returning
    return list(same_class), list(different_class)
